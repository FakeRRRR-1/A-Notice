<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤‡å¿˜å½•</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="/static/add.css" rel="stylesheet">
</head>
<body>
    {% csrf_token %}
    {% verbatim %}
    <div id="app" class="container">
        <h1 class="title">ğŸ“ å¤‡å¿˜å½•</h1>
        <div class="input-group">
            <input type="text" placeholder="è¯·è¾“å…¥æ–°ä»»åŠ¡..." v-model="task" :class="{ error: showError }" @keyup.enter="submit">
            <button class="submit-btn" @click="submit">
                <i class="fas fa-plus"></i> æ·»åŠ 
            </button>
            <button class="clear-btn" @click="ClearList">
                <i class="fas fa-trash-alt"></i> æ¸…ç©º
            </button>
        </div>
        <p class="error-message" v-if="showError">
            <i class="fas fa-exclamation-triangle"></i> è¯·è¾“å…¥ä»»åŠ¡å†…å®¹ï¼
        </p>
        
        <div class="content-area">
            <div v-if="list.length > 0" >
                <table>
                    <tr v-for="(item, index) in list" :key="item.databaseid" :class="{ completed: item.completed }">
                        <td>
                            <input v-if="item.editing" class="edit-input" v-model="item.name" @keyup.enter="saveEdit(item)" @blur="saveEdit(item)">
                            <span v-else @click="startEdit(item)">{{ index + 1 }}. {{ item.name }}</span>
                        </td>
                        <td>
                            <!-- æ—¶é—´ç»„ä»¶ -->
                            <i class="fas fa-clock"></i> {{ item.createdAt | formatDate }}          
                        </td>
                        <td>
                            <!-- å®Œæˆç»„ä»¶ -->
                            <input type="checkbox" v-model="item.completed">
                        </td>
                        <td>
                            <!-- åˆ é™¤ç»„ä»¶ -->
                            <button class="delete-btn" @click="del(item.databaseid)">
                                <i class="fas fa-trash"></i>
                            </button>
                        </td>
                    </tr>
                </table>
            </div>
            
            <div v-else class="empty-state">
                <i class="fas fa-clipboard-list"></i>
                <p>æš‚æ— ä»»åŠ¡</p>
                <small>æ·»åŠ ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡å¼€å§‹ç®¡ç†å§ï¼</small>
            </div>
        </div>
    </div>
    {% endverbatim %}

    <meta name="csrf-token" content="{{ csrf_token }}">
    <script>
        var app = new Vue({
            el: '#app',
            data: {
                task: '',
                showError: false,
                list: [],
            },
            filters: {
                formatDate(value) {
                    if (!value) return '';
                    return value;
                }
            },
            created() {
                this.getalldata();
            },
            methods: {
                async getalldata() {
                    const response = await fetch('/api/notice/');
                    if (!response.ok) {
                        console.error('è·å–æ•°æ®å¤±è´¥:', response.statusText);
                        return;
                    }
                    const data = await response.json();
                    if (data.notices && Array.isArray(data.notices)) {
                        this.list = data.notices.map(item => ({
                            id: item.id,
                            databaseid: item.id, // å‡è®¾è¿”å›çš„IDä¸æ•°æ®åº“ä¸­çš„IDä¸€è‡´
                            name: item.text,
                            completed: false, // é»˜è®¤æœªå®Œæˆ
                            editing: false,
                            createdAt: new Date().toISOString().slice(0, 16).replace('T', ' ')
                        }));
                    } else {
                        console.error('æ•°æ®æ ¼å¼ä¸æ­£ç¡®:', data);
                    }
                },
                async submit() {
                    if (this.task.trim()) {
                        this.showError = false;

                        try{
                            const response = await fetch('/api/notice/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': '{{ csrf_token }}'
                                },
                                body: JSON.stringify({ text: this.task }),

                            });
                            if (!response.ok) {
                                const errorData = await response.json();
                                console.error('æäº¤ä»»åŠ¡å¤±è´¥:', errorData);
                                alert('æäº¤ä»»åŠ¡å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚');
                                return;
                            }
                            const data = await response.json();
                           // debugger
                            const databaseid = data.notices.id; // è¿”å›æ•°æ®åº“ä¸­çš„id
                            console.log('ä»»åŠ¡æäº¤æˆåŠŸï¼ŒID:', databaseid);
                            const newId = this.list.length > 0 ? Math.max(...this.list.map(item => item.id)) + 1 : 1;
                            const now = new Date();
                            const offset = new Date().getTimezoneOffset() * 60000; // è½¬æ¢ä¸ºæ¯«ç§’
                            const localTime = new Date(Date.now() - offset).toISOString().slice(0, 16).replace('T', ' ');
                            this.list.push({ 
                                id: newId, 
                                databaseid: databaseid,
                                name: this.task, 
                                completed: false, 
                                editing: false, 
                                createdAt: localTime
                            });
                            this.task = '';
                        }catch (error) {
                            console.error('æäº¤ä»»åŠ¡æ—¶å‘ç”Ÿé”™è¯¯:', error);
                        }
                    } 
                    else {
                        this.showError = true;
                    }
                },
                async del(id) {
                    //console.log('åˆ é™¤ä»»åŠ¡ID:', id);
                    try {
                        const response = await fetch(`/api/notice/${id}/`, {
                            method: 'DELETE',
                            headers: {
                                'X-CSRFToken': '{{ csrf_token }}'
                            }
                        });
                        if (response.ok) {
                            this.list = this.list.filter(item => item.databaseid !== id);
                            //console.log('ä»»åŠ¡åˆ é™¤æˆåŠŸ,ID:', this.list.databaseid);
                        } else {
                            const errorData = await response.json();
                            console.error('åˆ é™¤ä»»åŠ¡å¤±è´¥:', errorData);
                            alert('åˆ é™¤ä»»åŠ¡å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚');
                        }
                    } catch (error) {
                        console.error('åˆ é™¤ä»»åŠ¡æ—¶å‘ç”Ÿé”™è¯¯:', error);
                    }
                },
                async ClearList() {
                    /*for (let i = 0; i < this.list.length; i++) {
                        this.del(this.list[i].databaseid);
                        console.log('æ¸…ç©ºä»»åŠ¡ID:', this.list[i].databaseid);
                    }*/
                    if (this.list.length === 0) {
                        alert('æ²¡æœ‰ä»»åŠ¡å¯ä»¥æ¸…ç©ºï¼');
                        return;
                    }
    
                    if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ä»»åŠ¡å—ï¼Ÿ')) {
                        return;
                    }
                    try {
                        const deletePromises = this.list.map(item => 
                            fetch(`/api/notice/${item.databaseid}/`, {
                                method: 'DELETE',
                                headers: {
                                    'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                                }
                            })
                        );
        
                        const responses = await Promise.allSettled(deletePromises);

                        await this.getalldata();

                        /*let successCount = 0;
                        let failCount = 0;
        
                        responses.forEach((result, index) => {
                            if (result.status === 'fulfilled' && result.value.ok) {
                                successCount++;
                            } 
                            else {
                                failCount++;
                            }
                        });
        
                        if (failCount === 0) {
                            this.list = [];
                            console.log(`æ‰€æœ‰ä»»åŠ¡å·²æ¸…ç©ºï¼Œå…±åˆ é™¤ ${successCount} ä¸ªä»»åŠ¡`);
                        } 
                        else {
                            await this.getalldata(); // é‡æ–°è·å–æ•°æ®ä¿æŒåŒæ­¥
                            alert(`æ¸…ç©ºå®Œæˆï¼Œä½†æœ‰ ${failCount} ä¸ªä»»åŠ¡åˆ é™¤å¤±è´¥`);
                        }*/
                    } 
                    catch (error) {
                        console.error('æ¸…ç©ºä»»åŠ¡æ—¶å‘ç”Ÿé”™è¯¯:', error);        
                    }
                },
                startEdit(item) {
                    //å°†æ‰€æœ‰editingçŠ¶æ€è®¾ç½®ä¸ºfalse
                    this.list.forEach(i => i.editing = false);
                    item.editing = true;
                    this.$nextTick(() => {
                        // æŸ¥æ‰¾å½“å‰ç¼–è¾‘çš„è¾“å…¥æ¡†å¹¶èšç„¦
                        const editInputs = this.$el.querySelectorAll('.edit-input');
                        if (editInputs.length > 0) {
                            editInputs[editInputs.length - 1].focus();
                        }
                    });
                },
                saveEdit(item) {
                    if (item.name.trim()) {
                        item.editing = false;
                    } else {
                        this.del(item.databaseid);
                    }
                }
            }
        });
    </script>
</body>
</html>